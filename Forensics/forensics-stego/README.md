# Stego‑2x Master - Personalised Write‑up

**Category:** Forensics – 500 pts  
**Flag:** `flag{stegosaurus}`

---

## Challenge Flow

1. You’re given a stego image (`cover.jpg`).  
2. Run bash exiftool -Comment cover.jpg to reveal the embedded QR filename (`scan_me.png`).
3. Extract the QR image: using exiftool -b -Comment cover.jpg > scan_me.png
4. Decode the QR to get the steghide passphrase: qrdecode -o - scan_me.png → p@ssW0rd123
5. Extract the hidden archive using the given password `steghide extract -sf cover.jpg -xf secret.zip -p p@ssW0rd123`
6. Unzip and read the flag:
7. Submit flag{stegosaurus}.

---

## How Difficulty Was Increased and Defence Mechanisms


I increased the difficulty by using 2 layers of steganography, this is because the task required for the QR code to be gotten from the EXIF then using a password to unlock another layer of the steghide. The difficulty was also very high due to the usage of a large number of unconventional tools, including exiftool, qrdecode, steghide and unzip. I had to use a fractal image so that the ZIP would fit inside the base image as the zip would not fit. This indicates the importance of checking key metadata like file sizes before actually using files.  The cover itself is a noise‑rich fractal (plasma:fractal) big enough to conceal the archive, the QR filename is metadata‑only so nothing in the pixels looks odd, and default‑password guesses fail because the only valid key lives inside the QR. 


---







### Build Section

This challenge is a two‑layer steganography pivot chain that starts from a single file `cover.jpg` and drives a four‑step extract→decode→extract→read path to a final archive whose contents contain the flag.
It implements the following artifacts:
the JPEG **EXIF Comment** that points at a QR image name `scan_me.png`, the **binary QR PNG** stored in the Comment itself (recoverable with `-b`), a **QR payload** that decodes to the steghide passphrase `p@ssW0rd123`, and a **steghide‑embedded ZIP** (`secret.zip`) inside `cover.jpg` that contains `flag.txt` with the final flag. Because some tools or hosts can strip metadata or recompress JPEGs, I validated that the distributed `cover.jpg` retains both the EXIF Comment and the steghide payload intact.

Because this artifact lives in image metadata, solvers must extract the EXIF Comment rather than look for pixel anomalies as the cover is generated by magick, the cover looks visually normal. The QR layer is intentionally light‑weight so the focus stays on pivot discipline, and the second layer (steghide) requires the QR‑derived password so accidental guesses fail. The major issues I accounted for were metadata stripping and capacity as a normal image was too small.

I used exif in this case to store the QR PNG (as binary data in the Comment) that yields the password for the inner stego layer. 


The tools I used were ImageMagick to make a high‑entropy cover using the fractal, zip/unzip to pack the flag file, steghide to embed the ZIP into the JPEG (F5‑style)., qrencode to render the passphrase as a QR PNG and exiftool to write/read the Comment tag and to stream binary data in/out of it.


The most important commands I used in this step were 
```bash
echo -n 'p@ssW0rd123' | qrencode -o scan_me.png -s 8 -m 2
exiftool -overwrite_original -Comment<=scan_me.png cover.jpg
```
as these allowed for the bytes of the qr code to be stored as comments in the cover.jpg

The entire command is underneath the steghide command where steghide is a command‑line steganography tool that hides data inside media files and later extracts it with a passphrase. It focuses on keeping the cover file visually/audibly unchanged while embedding bits in places that are hard to notice. The easiest way to notice these details is to examine the sizes of the images that used steghide.



---

### Solution Section

1. First I extract the initial metadata from the JPEG using EXIF tooling.
   It is a straightforward step to confirm whether the image contains a metadata hint.As a result, it can be used to recover the QR filename and proceed to the next step.
   The command I used was:

```bash
exiftool cover.jpg | grep -i 'comment'
```
and it gave me the results of

```
Comment                         : scan_me.png
```

2. Extract the QR image from the Comment (pivot to a binary file)

Use the binary (`-b`) extraction flag and redirect to a PNG:

```bash
exiftool -b -Comment cover.jpg > scan_me.png
```

This yields a decodable QR image file.

3. Decode the QR to recover the steghide passphrase

Use a simple QR decoder:

```bash
zbarimg --quiet --raw scan_me.png
```

and it gave me the results of

```
p@ssW0rd123
```

4. Extract the hidden archive using the recovered password

Run steghide against the same `cover.jpg`:

```bash
steghide extract -sf cover.jpg -xf secret.zip -p 'p@ssW0rd123'
```

This writes out the embedded ZIP (`secret.zip`) for the next step.

5. Unzip the archive and read the flag of flag{stegosaurus}

```bash
unzip -o secret.zip
cat flag.txt
```

and it gave me the results of

```
flag{stegosaurus}
```




## Related & Future Forensics Variants

- Using a chain of QR codes across multiple images, where each extraction reveals the filename of the next cover file requiring recursive metadata analysis
- Using audio steganography to hide a compressed archive within a WAV file, with hints embedded in the RIFF chunk comments
- Employing DNS tunneling to split a hidden payload across multiple DNS TXT queries, forcing solvers to reconstruct the archive from network logs

---










### Sources

- **ExifTool** https://exiftool.org/
- **Steghide** https://steghide.sourceforge.net/
- **qrencode/qrdecode** https://github.com/nayuki/QR-Code-generator
- **ForensicsWiki** https://www.forensicswiki.org/  
